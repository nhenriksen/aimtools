import os,sys,re
import numpy as np
import subprocess as sp
import parmed as pmd


def _create_atom_type_list(first_chars,second_chars):
    """ Create all possible two character atom types """

    # NMH: Could make this into a list comprehension probably.

    types = []
    for first_char in first_chars:
        for second_char in second_chars:
            types.append(first_char+second_char)
    return types


def assign_uniq_types(parm,equiv_file):
    """ Generate unique atom types for each unique atom """

    # NMH: Add support for input of multiple parms simultaneously, so
    #      that types don't overlap over a series of molecules

    ### ASCII Characters to consider
    char_list = "0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r\
                 s t u v w x y z A B C D E F G H I J K L M N O P Q R S T\
                 U V W X Y Z * & $ # % [ ] { } < > ? - + = : ; ' . , ! ~\
                 ` @ ^ ( ) _ | / \\ \"".split()
    char_list.append(' ')

    # NMH: Are there any protected/hardcoded types that must be avoided?
    
    ### Generate atom type lists. We'll prioritize certain names for
    #   common elements.
    type_list = {}
    type_list['h'] =   _create_atom_type_list(['h','H','1'],char_list)
    type_list['c'] =   _create_atom_type_list(['c','C','6'],char_list)
    type_list['n'] =   _create_atom_type_list(['n','N','7'],char_list)
    type_list['o'] =   _create_atom_type_list(['o','O','8'],char_list)
    type_list['f'] =   _create_atom_type_list(['f','F','9'],char_list)
    type_list['p'] =   _create_atom_type_list(['p','P','q'],char_list)
    type_list['s'] =   _create_atom_type_list(['s','S','Z'],char_list)
    type_list['cl'] =  _create_atom_type_list(['l','L','!'],char_list)
    type_list['br'] =  _create_atom_type_list(['b','B','$'],char_list)
    type_list['i'] =   _create_atom_type_list(['i','I','|'],char_list)
    # Do not use space as a first character in atom type
    type_list['all'] = _create_atom_type_list(char_list[:-1],char_list)

    ### Create a per-element index counter for atom types to bookkeep 
    #   the types in use
    type_idx = {'h': 0, 'c': 0, 'n': 0, 'o': 0, 'f': 0, 'p': 0, 's': 0,\
                'cl': 0, 'br': 0, 'i': 0, 'all': 0}

    ### New unique types. Will correspond with atom index.
    uniq_types = []

    ### Get equivalent atom id's generated by Niel's patched antechamber.
    #   The first instance of a unique atom is assigned value of zero, 
    #   and remaining equivalent atoms are assigned the index value of the
    #   first atom of that unique type. Indexes start at 1.
    equiv_idxs,equiv_ids = np.loadtxt(equiv_file, dtype=np.int32,\
                           skiprows=1, usecols=(3,4), unpack=True)

    ### Loop over all atoms in parm to assign uniq_types
    for i,atom in enumerate(parm):
        orig_type = atom.type
        # Identify elements ... Cl and Br are common two character types
        if orig_type == 'cl' or orig_type == 'br':
            element = orig_type
        else:
            element = orig_type[0]
        # If the equiv_id is not 0, then there is another atom to which
        # it is equivalent, so we should assign it the same uniq_type.
        if equiv_ids[i] != 0:
            uniq_type = uniq_types[equiv_ids[i]-1]
        else:
            # This is a new unique atom, so assign a new type
            if type_idx[element] < len(type_list[element]):
                # We still have types available that have priority names
                uniq_type = type_list[element][type_idx[element]]
                type_idx[element] += 1
            else:
                # We ran out of priority names, taking from all possible.
                # First skip over any types already in use.
                while type_list['all'][type_idx['all']] in uniq_types:
                    type_idx['all'] += 1
                uniq_type = type_list['all'][type_idx['all']]
                type_idx['all'] += 1
        uniq_types.append(uniq_type)

    return uniq_types

def write_unique_frcmod(parm,unique_types,frcmod_file):
    """ Create frcmod with terms for each unique atom """

    ### Replace atom types in raw parm data lists
    parm.parm_data['AMBER_ATOM_TYPE'] = unique_types
    ### Run parmed incantation for "re-initializing" all the parameters
    parm.load_atom_info()
    parm.fill_LJ()
    ### Create parmset (organized list of the parameters)
    parmset = pmd.amber.AmberParameterSet.from_structure(parm)
    ### Write the frcmod
    parmset.write(frcmod_file)


def write_unique_mol2(orig_mol2_file,uniq_types,uniq_mol2_file):
    """ Replace GAFF atom types with unique types """

    # NMH: If I update write_unique_frcmod to edit the parm object
    #      directly, I should edit this to do that as well.

    ### Open new mol2 which will have unique types
    uniq_mol2 = open(uniq_mol2_file,'w')

    ### Run through orig mol2, replace orig types with unique
    with open(orig_mol2_file,'r') as mol2file:
        mol2_lines = mol2file.readlines()
        # Only process if we are in the right section
        Record = False
        for line in mol2_lines:
            # BOND section means we are done processing
            if re.search(r'@<TRIPOS>BOND',line):
                Record = False
            # Process the lines if Record == True
            if Record:
                aidx,aname,x,y,z,atype,rnum,rname,chg = line.rstrip().split()
                uniq_mol2.write(
                    "{:>7s} {:<4s}     {:10.4f} {:10.4f} {:10.4f}"\
                    " {:<4s}  {:>6s} {:<3s}     {:10.6f}\n"\
                    .format(aidx,aname,float(x),float(y),float(z),
                    uniq_types[int(aidx)-1],rnum,rname,float(chg))
                )
            else:
                uniq_mol2.write(line)
            # ATOM section is the beginning of when we want to record
            if re.search(r'@<TRIPOS>ATOM',line):
                Record = True
    uniq_mol2.close()

### Execute
if __name__ == '__main__':
    parm = pmd.amber.LoadParm('vac.prmtop')
    uniq_types = assign_uniq_types(parm,'EQUIVATOMS.DAT')
    write_unique_frcmod(parm,uniq_types,'uniq.frcmod')
    write_unique_mol2('ante.mol2',uniq_types,'uniq.mol2')



