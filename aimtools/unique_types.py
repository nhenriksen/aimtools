import os,sys,re
import numpy as np
import subprocess as sp
import parmed as pmd


def _create_atom_type_list(first_chars,second_chars):
    """ Create all possible two character atom types """

    # NMH: Could make this into a list comprehension probably.

    types = []
    for first_char in first_chars:
        for second_char in second_chars:
            types.append(first_char+second_char)
    return types


def assign_uniq_types(parm,equiv_file):
    """ Generate unique atom types for each unique atom """

    # NMH: Add support for input of multiple parms simultaneously, so
    #      that types don't overlap over a series of molecules

    ### ASCII Characters to consider
    char_list = "0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r\
                 s t u v w x y z A B C D E F G H I J K L M N O P Q R S T\
                 U V W X Y Z * & $ # % [ ] { } < > ? - + = : ; ' . , ! ~\
                 ` @ ^ ( ) _ | / \\ \"".split()
    char_list.append(' ')

    # NMH: Are there any protected/hardcoded types that must be avoided?
    
    ### Generate atom type lists. We'll prioritize certain names for
    #   common elements.
    type_list = {}
    type_list['h'] =   _create_atom_type_list(['h','H','1'],char_list)
    type_list['c'] =   _create_atom_type_list(['c','C','6'],char_list)
    type_list['n'] =   _create_atom_type_list(['n','N','7'],char_list)
    type_list['o'] =   _create_atom_type_list(['o','O','8'],char_list)
    type_list['f'] =   _create_atom_type_list(['f','F','9'],char_list)
    type_list['p'] =   _create_atom_type_list(['p','P','q'],char_list)
    type_list['s'] =   _create_atom_type_list(['s','S','Z'],char_list)
    type_list['cl'] =  _create_atom_type_list(['l','L','!'],char_list)
    type_list['br'] =  _create_atom_type_list(['b','B','$'],char_list)
    type_list['i'] =   _create_atom_type_list(['i','I','|'],char_list)
    # Do not use space as a first character in atom type
    type_list['all'] = _create_atom_type_list(char_list[:-1],char_list)

    ### Create a per-element index counter for atom types to bookkeep 
    #   the types in use
    type_idx = {'h': 0, 'c': 0, 'n': 0, 'o': 0, 'f': 0, 'p': 0, 's': 0,\
                'cl': 0, 'br': 0, 'i': 0, 'all': 0}

    ### New unique types. Will correspond with atom index.
    uniq_types = []

    ### Get equivalent atom id's generated by Niel's patched antechamber.
    #   The first instance of a unique atom is assigned value of zero, 
    #   and remaining equivalent atoms are assigned the index value of the
    #   first atom of that unique type. Indexes start at 1.
    equiv_idxs,equiv_ids = np.loadtxt(equiv_file, dtype=np.int32,\
                           skiprows=1, usecols=(3,4), unpack=True)

    ### Loop over all atoms in parm to assign uniq_types
    for i,atom in enumerate(parm):
        orig_type = atom.type
        # Identify elements ... Cl and Br are common two character types
        if orig_type == 'cl' or orig_type == 'br':
            element = orig_type
        else:
            element = orig_type[0]
        # If the equiv_id is not 0, then there is another atom to which
        # it is equivalent, so we should assign it the same uniq_type.
        if equiv_ids[i] != 0:
            uniq_type = uniq_types[equiv_ids[i]-1]
        else:
            # This is a new unique atom, so assign a new type
            if type_idx[element] < len(type_list[element]):
                # We still have types available that have priority names
                uniq_type = type_list[element][type_idx[element]]
                type_idx[element] += 1
            else:
                # We ran out of priority names, taking from all possible.
                # First skip over any types already in use.
                while type_list['all'][type_idx['all']] in uniq_types:
                    type_idx['all'] += 1
                uniq_type = type_list['all'][type_idx['all']]
                type_idx['all'] += 1
        uniq_types.append(uniq_type)

    return uniq_types

def write_unique_frcmod(parm,unique_types,frcmod_file):
    """ Create frcmod with terms for each unique atom """

    ### Replace atom types in raw parm data lists
    parm.parm_data['AMBER_ATOM_TYPE'] = unique_types
    ### Run parmed incantation for "re-initializing" all the parameters
    parm.load_atom_info()
    parm.fill_LJ()
    ### Create parmset (organized list of the parameters)
    parmset = pmd.amber.AmberParameterSet.from_structure(parm)
    ### Write the frcmod
    parmset.write(frcmod_file)


def old_write_unique_frcmod(parm_file,uniq_types,uniq_frcmod_file):
    """ Create frcmod for uniq_types corresponding to the original FF """
    # NMH: add cwd support
    # NMH: I think this could be updated to apply the unique types directly
    #      to the parm structure, rather than sp.call'ing parmed. But in the
    #      interest of getting a working prototype, we'll do this.

    ### Generate parameter information via parmed
    with open('parmed-info.in', 'w') as parmedfile:
        parmedfile.write("""\
parm {}
printdetails *
printBonds
printAngles
printDihedrals
quit
        """.format(parm_file))
    parmlog = open('parmed-info.log', 'w')
    sp.call(['parmed','-i','parmed-info.in'],stdout=parmlog,
            stderr=parmlog)
    parmlog.close()

    ### Setup lists for each force field term
    mass_params = []
    bond_params = []
    angle_params = []
    dihedral_params = []
    improper_params = []
    lj_params = []

    ### Read parmed output
    with open('parmed-info.log','r') as parmlog:
        parm_lines = parmlog.readlines()

    ### Loop over parmed output, replace old atom types with new uniques
    for i,line in enumerate(parm_lines):
        # Identify Mass and LJ params, retype with new unique atom types
        if re.search(r'^   ATOM',line):
            j = i + 1
            while parm_lines[j] != '\n':
                cols = parm_lines[j].rstrip().split()
                # get unique type by looking up with atom serial number
                ut = uniq_types[int(cols[0])-1]
                name = cols[3]
                rad = float(cols[6])
                eps = float(cols[7])
                mass = float(cols[8])
                param = "{:<2s}   {:9.4f}   0.0000   # {:<s}\n".format(
                          ut,      mass,                name )
                if not param in mass_params:
                    mass_params.append(param)
                    lj_params.append("  {:<2s}   {:9.5f}   {:9.5f}\n"
                                     .format(ut,rad,eps))
                j += 1
        # Identify Bond params, retype with new unique atom types
        if re.search(r'Atom 2       R eq',line):
            j = i + 1
            while parm_lines[j] != '\n':
                cols = parm_lines[j].rstrip().split()
                ut1 = uniq_types[int(cols[0])-1]
                ut2 = uniq_types[int(cols[4])-1]
                req = float(cols[8])
                fcn = float(cols[9])
                param = "{:<2s}-{:<2s}   {:9.4f}   {:10.5f} \n".format(
                          ut1,   ut2,     fcn,      req)
                if not param in bond_params:
                    bond_params.append(param)
                j += 1
        # Identify Angle params, retype with new unique atom types
        if re.search(r'Atom 3   Frc Cnst',line):
            j = i + 1
            while parm_lines[j] != '\n':
                cols = parm_lines[j].rstrip().split()
                ut1 = uniq_types[int(cols[0])-1]
                ut2 = uniq_types[int(cols[4])-1]
                ut3 = uniq_types[int(cols[8])-1]
                fcn = float(cols[12])
                teq = float(cols[13])
                param = "{:<2s}-{:<2s}-{:<2s}   {:9.4f}   {:9.4f} \n"\
                        .format(ut1,ut2,ut3,   fcn,      teq)
                if not param in angle_params:
                    angle_params.append(param)
                j += 1
        # Identify Dihedrals/Impropers, retype with new unique atom typesq
        if re.search(r'Atom 4     Height',line):
            j = i + 1
            while parm_lines[j] != '\n':
                cols = parm_lines[j].rstrip().split()
                ut1 = uniq_types[int(cols[-21])-1]
                ut2 = uniq_types[int(cols[-17])-1]
                ut3 = uniq_types[int(cols[-13])-1]
                ut4 = uniq_types[int(cols[-9])-1]
                utstr = "{:<2s}-{:<2s}-{:<2s}-{:<2s}".format(
                          ut1,   ut2,   ut3,   ut4)
                height = float(cols[-5])
                period = float(cols[-4])
                phase = float(cols[-3])
                # NMH ADD SCEE AND SCNB COLUMNS!!!!!
                if cols[0] == "I":
                    param = "{:<11s}       {:9.4f}   {:9.4f}   {:9.4f} \n"\
                            .format(utstr,height,phase,period)
                    if not param in improper_params:
                        improper_params.append(param)
                else:
                    param = "{:<11s}   1   {:9.4f}   {:9.4f}   {:9.4f} \n"\
                            .format(utstr,height,phase,period)
                    if not param in dihedral_params:
                        dihedral_params.append(param)
                j += 1

    ### Recheck the dihedrals and add negative signs to periodicities for
    #   which additional lines for the same dihedral follow (per AMBER).
    for i,param in enumerate(dihedral_params[:-1]):
        cols = param.rstrip().split()
        nexcols = dihedral_params[i+1].rstrip().split()
        # If the next dihedral matches the current, -1*periodicity
        if cols[0] == nexcols[0]:
            dihedral_params[i] = "{:s}   {:s}   {:9.4f}   {:9.4f}   {:9.4f}\n"\
                                  .format(cols[0],cols[1],float(cols[2]),
                                  float(cols[3]),-1*float(cols[4]))
        
    ### Write new frcmod
    with open(uniq_frcmod_file,'w') as frcmod:
        frcmod.write("Unique Atom Frcmod by Niel\nMASS\n")
        for param in mass_params:
            frcmod.write(param)
        frcmod.write("\nBOND\n")
        for param in bond_params:
            frcmod.write(param)
        frcmod.write("\nANGLE\n")
        for param in angle_params:
            frcmod.write(param)
        frcmod.write("\nDIHE\n")
        for param in dihedral_params:
            frcmod.write(param)
        frcmod.write("\nIMPROPER\n")
        for param in improper_params:
            frcmod.write(param)
        frcmod.write("\nNONBON\n")
        for param in lj_params:
            frcmod.write(param)
            # NOTE THAT GB RADII are determined with hardfixed atom type
            # matching, so prmtop's made with this frcmod will not have
            # correct GB RADII
        frcmod.write("\n")

    ### Done
    return 0
    

def write_unique_mol2(orig_mol2_file,uniq_types,uniq_mol2_file):
    """ Replace GAFF atom types with unique types """

    # NMH: If I update write_unique_frcmod to edit the parm object
    #      directly, I should edit this to do that as well.

    ### Open new mol2 which will have unique types
    uniq_mol2 = open(uniq_mol2_file,'w')

    ### Run through orig mol2, replace orig types with unique
    with open(orig_mol2_file,'r') as mol2file:
        mol2_lines = mol2file.readlines()
        # Only process if we are in the right section
        Record = False
        for line in mol2_lines:
            # BOND section means we are done processing
            if re.search(r'@<TRIPOS>BOND',line):
                Record = False
            # Process the lines if Record == True
            if Record:
                aidx,aname,x,y,z,atype,rnum,rname,chg = line.rstrip().split()
                uniq_mol2.write(
                    "{:>7s} {:<4s}     {:10.4f} {:10.4f} {:10.4f}"\
                    " {:<4s}  {:>6s} {:<3s}     {:10.6f}\n"\
                    .format(aidx,aname,float(x),float(y),float(z),
                    uniq_types[int(aidx)-1],rnum,rname,float(chg))
                )
            else:
                uniq_mol2.write(line)
            # ATOM section is the beginning of when we want to record
            if re.search(r'@<TRIPOS>ATOM',line):
                Record = True
    uniq_mol2.close()

### Execute
### Assumes you 
if __name__ == '__main__':
    parm = pmd.amber.LoadParm('vac.prmtop')
    uniq_types = assign_uniq_types(parm,'EQUIVATOMS.DAT')
    write_unique_frcmod(parm,uniq_types,'uniq.frcmod')
    write_unique_mol2('ante.mol2',uniq_types,'uniq.mol2')



