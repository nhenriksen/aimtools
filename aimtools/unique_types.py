import sys
import numpy as np
import subprocess as sp
import parmed as pmd


def _create_atom_type_list(first_chars, second_chars):
    """ Create all possible two character atom types """

    # NMH: Could make this into a list comprehension probably.

    types = []
    for first_char in first_chars:
        for second_char in second_chars:
            types.append(first_char + second_char)
    return types


def assign_unique_types(parm, equiv_ids, type_list, type_idx):
    """ Inspect the parms and assign unique atom types """

    unique_types = []

    for i, atom in enumerate(parm):
        orig_type = atom.type
        # Identify elements ... Cl and Br are common two character types
        if orig_type == 'cl' or orig_type == 'br':
            element = orig_type
        else:
            element = orig_type[0]
        # If the equiv_id is not 0, then there is another atom to which
        # it is equivalent, so we should assign it the same uniquetype.
        if equiv_ids[i] != 0:
            unique_type = unique_types[equiv_ids[i] - 1]
        else:
            # This is a new unique atom, so assign a new type
            if type_idx[element] < len(type_list[element]):
                # We still have types available that have priority names
                unique_type = type_list[element][type_idx[element]]
                type_idx[element] += 1
            else:
                # We ran out of priority names, taking from all possible.
                # First skip over any types already in use.
                while type_list['all'][type_idx['all']] in unique_types:
                    type_idx['all'] += 1
                unique_type = type_list['all'][type_idx['all']]
                type_idx['all'] += 1
        unique_types.append(unique_type)

    return unique_types


def create_unique_type_list(parm_list, equiv_file_list):
    """ Generate unique atom types for each unique atom """

    ### Maintain the convenience of not specifying as list
    if not isinstance(parm_list, list):
        parm_list = [parm_list]
    if not isinstance(equiv_file_list, list):
        equiv_file_list = [equiv_file_list]

    ### ASCII Characters to consider (don't use dash, "-"!)
    char_list = "0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r\
                 s t u v w x y z A B C D E F G H I J K L M N O P Q R S T\
                 U V W X Y Z * & $ # % [ ] { } < > ? + = : ; ' . , ! ~ `\
                 @ ^ ( ) _ | / \\ \"".split()
    char_list.append(' ')

    # NMH: Are there any protected/hardcoded types that must be avoided?

    ### Generate atom type lists. We'll prioritize certain names for
    #   common elements.
    type_list = {}
    type_list['h'] = _create_atom_type_list(['h', 'H', '1'], char_list)
    type_list['c'] = _create_atom_type_list(['c', 'C', '6'], char_list)
    type_list['n'] = _create_atom_type_list(['n', 'N', '7'], char_list)
    type_list['o'] = _create_atom_type_list(['o', 'O', '8'], char_list)
    type_list['f'] = _create_atom_type_list(['f', 'F', '9'], char_list)
    type_list['p'] = _create_atom_type_list(['p', 'P', 'q'], char_list)
    type_list['s'] = _create_atom_type_list(['s', 'S', 'Z'], char_list)
    type_list['cl'] = _create_atom_type_list(['l', 'L', '!'], char_list)
    type_list['br'] = _create_atom_type_list(['b', 'B', '$'], char_list)
    type_list['i'] = _create_atom_type_list(['i', 'I', '|'], char_list)
    # Do not use space as a first character in atom type
    type_list['all'] = _create_atom_type_list(char_list[:-1], char_list)

    ### Create a per-element index counter for atom types to bookkeep
    #   the types in use
    type_idx = {'h': 0, 'c': 0, 'n': 0, 'o': 0, 'f': 0, 'p': 0, 's': 0,\
                'cl': 0, 'br': 0, 'i': 0, 'all': 0}

    ### New unique types. Will correspond with atom index.
    unique_types = []

    for i, parm in enumerate(parm_list):

        ### Get equivalent atom id's generated by Niel's patched antechamber.
        #   The first instance of a unique atom is assigned value of zero,
        #   and remaining equivalent atoms are assigned the index value of the
        #   first atom of that unique type. Indexes start at 1.
        equiv_file = equiv_file_list[i]
        equiv_idxs,equiv_ids = np.loadtxt(equiv_file, dtype=np.int32,\
                           skiprows=1, usecols=(3,4), unpack=True)

        ### ADD COMMENT
        unique_types.append(
            assign_unique_types(parm, equiv_ids, type_list, type_idx))

    return unique_types


def write_unique_frcmod_mol2s(parm_list,
                              unique_types,
                              frcmod_file,
                              name_list=None):
    """ Create frcmod with terms for each unique atom """

    ### Maintain the convenience of not specifying as list
    if not isinstance(parm_list, list):
        parm_list = [parm_list]
    if not isinstance(name_list, list):
        name_list = [name_list]

    ### Will need to keep track of frcmods that are written
    frcmod_list = []

    for i, parm in enumerate(parm_list):
        ### Replace atom types in raw parm data lists
        parm.parm_data['AMBER_ATOM_TYPE'] = unique_types[i]
        ### Run parmed incantation for "re-initializing" all the parameters
        parm.load_atom_info()
        parm.fill_LJ()
        ### Create parmset (organized list of the parameters)
        parmset = pmd.amber.AmberParameterSet.from_structure(parm)
        ### Write the individual molecule frcmod and mol2
        if name_list == [None]:
            indiv_frcmod = 'mol_' + str(i) + '.frcmod'
            mol2 = 'mol_' + str(i) + '.mol2'
        else:
            indiv_frcmod = name_list[i] + '.frcmod'
            mol2 = name_list[i] + '.mol2'
        parmset.write(indiv_frcmod)
        frcmod_list.append(indiv_frcmod)
        parm.save(mol2, overwrite=True)

    ### Can't figure out a way to skip the 'write out individual frcmod
    #   and then read them all in to generate complete frcmod' approach.
    #   Don't see a way to combine parmsets.  Should look more ...
    parmset = pmd.amber.AmberParameterSet(frcmod_list)
    parmset.write(frcmod_file)


### Execute
if __name__ == '__main__':
    ### Setup input arguments
    if len(sys.argv) < 4:
        print("  Arguments: <'parm ...'> <'crds ...'> <'eqv_file ...'> [<'name_prefix ...'>]")
        print("  -Note: Quotes are not required if only one item is provided\n") 
        sys.exit()
    parm_list = sys.argv[1].split()
    crds_list = sys.argv[2].split()
    equiv_list = sys.argv[3].split()
    if len(sys.argv) == 5:
        name_list = sys.argv[4].split()
    else:
        name_list=None

    ### Load parms/crds, replace parm filename with parm object parm_list
    for i,parm_name in enumerate(parm_list):
        parm = pmd.amber.LoadParm(parm_name)
        parm.load_rst7(crds_list[i])
        parm_list[i] = parm
    
    ### Execute
    unique_types = create_unique_type_list(parm_list, equiv_list)
    write_unique_frcmod_mol2s(parm_list, unique_types, 'all_unique.frcmod', name_list=name_list)

